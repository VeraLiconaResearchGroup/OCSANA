/*
 * Copyright (C) 2015 misagh.kordi
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.cytoscape.myapp.internal;

import java.util.ArrayList;
import java.util.Vector;

/**
 *
 * @author misagh.kordi
 */
public class hittingSetGreedyAlgorithm {
    
    
    private int[] source;
    
    private int[] target;

    private int[] offtarget;
    
    private Float inputArr[];
    
    private ArrayList<Node> nodeList;
    
    private Vector<Vector<Integer>> pathes;
    
    private Vector<Vector<Integer>> elementarypathes;
    
    private int radius;

    public Vector<Vector<Integer>> getElementarypathes() {
        return elementarypathes;
    }

    public void setElementarypathes() {
        
        for (int i = 0; i < pathes.size(); i++) {
            Vector<Integer> getV = pathes.get(i);
            
            int sink;
            
            sink = getV.get(getV.size()-1);
            for (int j = 0; j < target.length; j++) {
                
                if (target[j] == sink) {
                    
                    elementarypathes.add(getV);
                    break;                   
                }               
            }          
        }
    }
     
    private int largeCardinality;
     
    private int largNumberOfCandidate;
     
    private Vector<Float> ocsanaScore;
     
    private Vector<Integer> elementaryNOdes;
     
    private Float[] array;
    
    private int length;
    
    private int[] setscoreset;
    
    private int[][] elementryPathArray;
    
    private a hittingsetGreedyGUI;

    public hittingSetGreedyAlgorithm(int[] source, int[] target, int[] offtarget, Vector<Vector<Integer>> pathes, int radius, int largeCardinality, int largNumberOfCandidate, Vector<Float> ocsanaScore, Vector<Integer> elementaryNOdes) {
        this.source = source;
        this.target = target;
        this.offtarget = offtarget;
        this.pathes = pathes;
        this.radius = radius;
        this.largeCardinality = largeCardinality;
        this.largNumberOfCandidate = largNumberOfCandidate;
        this.ocsanaScore = ocsanaScore;
        this.elementaryNOdes = elementaryNOdes;
    }

    private void initial(){
    
        hittingsetGreedyGUI =  new a();
        hittingsetGreedyGUI.setTitle("hittingsetGreedyGUI");
        hittingsetGreedyGUI.setVisible(true);
        
        sort();
        
        elementaryPathArray();
    
    }
    
    public Vector<Integer> getElementaryNOdes() {
        return elementaryNOdes;
    }

    public void setElementaryNOdes(Vector<Integer> elementaryNOdes) {
        this.elementaryNOdes = elementaryNOdes;
    }

    public Vector<Float> getOcsanaScore() {
        return ocsanaScore;
    }

    public void setOcsanaScore(Vector<Float> ocsanaScore) {
        this.ocsanaScore = ocsanaScore;
    }   

    public int[] getSource() {
        return source;
    }

    public void setSource(int[] source) {
        this.source = source;
    }

    public int[] getTarget() {
        return target;
    }

    public void setTarget(int[] target) {
        this.target = target;
    }

    public int[] getOfftarget() {
        return offtarget;
    }

    public void setOfftarget(int[] offtarget) {
        this.offtarget = offtarget;
    }

    public Vector<Vector<Integer>> getPathes() {
        return pathes;
    }

    public void setPathes(Vector<Vector<Integer>> pathes) {
        this.pathes = pathes;
    }

    public int getRadius() {
        return radius;
    }

    public void setRadius(int radius) {
        this.radius = radius;
    }

    public int getLargeCardinality() {
        return largeCardinality;
    }

    public void setLargeCardinality(int largeCardinality) {
        this.largeCardinality = largeCardinality;
    }

    public int getLargNumberOfCandidate() {
        return largNumberOfCandidate;
    }

    public void setLargNumberOfCandidate(int largNumberOfCandidate) {
        this.largNumberOfCandidate = largNumberOfCandidate;
    }
 
    public void sort() {
        
        int count = 0;
        inputArr = new Float[ocsanaScore.size()];
        for(int i=0 ; i< ocsanaScore.size() ; i++) 
            inputArr[count++] = ocsanaScore.get(i);
        this.array = inputArr;
        length = inputArr.length;
        quickSort(0, length - 1);
    }
 
    private void quickSort(int lowerIndex, int higherIndex) {
         
        int i = lowerIndex;
        int j = higherIndex;
        // calculate pivot number, I am taking pivot as middle index number
        Float pivot = array[lowerIndex+(higherIndex-lowerIndex)/2];
        // Divide into two arrays
        while (i <= j) {
            /**
             * In each iteration, we will identify a number from left side which
             * is greater then the pivot value, and also we will identify a number
             * from right side which is less then the pivot value. Once the search
             * is done, then we exchange both numbers.
             */
            while (array[i] < pivot) {
                i++;
            }
            while (array[j] > pivot) {
                j--;
            }
            if (i <= j) {
                
                exchangeNumbers(i, j);
                //move index to next position on both sides
                i++;
                j--;
            }
        }
        // call quickSort() method recursively
        if (lowerIndex < j)
            quickSort(lowerIndex, j);
        if (i < higherIndex)
            quickSort(i, higherIndex);
    }
 
    private void exchangeNumbers(int i, int j) {
         
        Float temp = array[i];
        int tempelementarynode;
        tempelementarynode = elementaryNOdes.get(i);
        
        if(i<j | setscoreset[j] <setscoreset[i]){
 
        array[i] = array[j];
        array[j] = temp;
        elementaryNOdes.setElementAt(i, elementaryNOdes.get(j));
        elementaryNOdes.set(j, tempelementarynode);  
        
        }
    }
    
    private void elementaryPathArray(){
    
        int N = elementaryNOdes.size();
        
        int p = elementarypathes.size();
       
        elementryPathArray =  new int[p+1][N+1];
        
        for (int i = 0; i < p+1; i++) {
            
            for (int j = 0; j < N+1; j++) {
                elementryPathArray[i][j] = 0;           
            }
        }
        
        for (int i = 1; i < elementarypathes.size(); i++) {
            
            for (int j = 0; j < elementarypathes.get(i).size(); j++) {
                elementryPathArray[i][elementarypathes.get(i).get(j)] = 1;                
            }
        }   
    } 
    
    private boolean exceptionone(){
    
        boolean excep =  false;
        
        int count = 0;
        
        for (int i = 1; i < elementarypathes.size(); i++) {
            
            count = 0;
            for (int j = 0; j < elementarypathes.get(i).size(); j++) {
               if( elementryPathArray[i][j] == 1)
                   count++;
            }
            if (count == 1) {
                elementryPathArray[i][elementryPathArray[i].length-1] = -1;
                excep =  true;
            }
        } 
        return excep;
    }
    
    private void kEqualOne(){
    
        int count = 0;
        
        int N = elementarypathes.get(0).size() -1;
        
        for (int i = 0; i < N; i++) {
            
            count = 0;
            for (int j = 1; j < elementarypathes.size(); j++) {
               if( elementryPathArray[j][i] == 1)
                   count++;
            }
            if (count == elementarypathes.size()-1) {
                hittingsetGreedyGUI.txt.append(nodeList.get(i).getName()+"\n");
                elementryPathArray[0][i] = -2;
            }
        } 
    }
    
    private void allpossiblesubset(){
    
         int count = 0;
         
         int NPrime = 0;
         
         int c2nprime = 0;
         
         int[][] H2;
         
         Vector<Integer> NprimeOrder =  new Vector<>();
          Vector<Integer> NprimeVectore =  new Vector<>();
         Vector<Vector<Integer>> U=  new Vector<>();
         Vector<Integer> tempvector=  new Vector<>();
        
        int N = elementarypathes.get(0).size() -1;
        
        for (int i = 0; i < N; i++) {
            if (elementryPathArray[0][i] != -2) {
                NprimeOrder.add(elementaryNOdes.get(i));
                NprimeVectore.add(elementaryNOdes.get(i));
                count++;
            }
        }
        
        NPrime = count;
        
        c2nprime = (int)((NPrime*(NPrime-1))/2);
        
        H2 = new int[c2nprime+1][NPrime+1];
        
        for (int i = 0; i < c2nprime+1; i++) {
           
            for (int j = 0; j < NPrime+1; j++) {
                
                H2[i][j] = 0;               
            }           
        }
        int p = 1;
        int q = 1 ;
        int t = 0;
        
        while(true){
        
            H2[p][t] = 1;
            if(q < NPrime){
            
                H2[p][q] = 1;          
                q++;
            }
            else{
               t++;
               q = t+1;
            }
            if (q ==NPrime ) {
                break;
            }
        p++;
        }
        int elementarypathhit = 0;
        int tempvalue1 = -1;
        int tempvalue2 = -1;
        Vector<Vector<Integer>> Useed =  new Vector<>();
        
        for (int i = 1; i < c2nprime+1; i++) {
            
            tempvalue1 = -1;
            tempvalue2 = -1;
            elementarypathhit = 0;
            
            for(int j = 0 ; j< NPrime ;j++)
                if(H2[i][j] == 1){
                
                    if(tempvalue1 != -1)
                        tempvalue1 = j;
                    else
                        tempvalue2 = j;
                }
            
            for (int j = 0; j < elementarypathes.size(); j++) {
                
                if (elementarypathes.get(j).contains(NprimeOrder.get(tempvalue1)) | elementarypathes.get(j).contains(NprimeOrder.get(tempvalue2))) {
                    elementarypathhit++;
                }               
            }
            
            if(elementarypathhit == elementarypathes.size()){    
                hittingsetGreedyGUI.txt.append(nodeList.get(tempvalue1).getName()+"   "+ nodeList.get(tempvalue2).getName());            
            }
            else{
                tempvector.add(tempvalue1);
                tempvector.add(tempvalue2);
                Useed.add(tempvector);
                tempvector.clear();
            }                     
        }
        
        for (int k = 3; k < largeCardinality; k++) {
          
            if (k == largeCardinality-1 & exceptionone()) {
                break;
            }
          //  if ((NPrime-k+1)*Useed.size() <largNumberOfCandidate) {
                
                for (int i = 0; i < NprimeVectore.size(); i++) {
                    for (int j = 0; j < Useed.size(); j++) {
                        if(Useed.get(j).contains(NprimeVectore.get(i))){
                        
                            NprimeVectore.removeElementAt(i);
                        } 
                    }                   
                }
                boolean exit = false;
                for (int i = 0; i < NprimeVectore.size(); i++) {
                    for (int j = 0; j < Useed.size(); j++) {
                        tempvector = Useed.get(j);
                        tempvector.add(NprimeVectore.get(i));
                        U.add(tempvector);
                        tempvector.clear();
                        if(U.size() == largNumberOfCandidate){
                        
                            exit = true;
                            break;
                        }
                    }   
                    if (exit) {
                        break;
                    }
                }
              
                NPrime = NprimeVectore.size();
           // } 
            for (int i = 0; i < Useed.size(); i++) {
                
            }
        }
    }
    
    
}
