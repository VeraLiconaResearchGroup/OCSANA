/**
 * 
 */
package org.cytoscape.myapp.internal;

import java.awt.List;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Vector;

import javax.swing.text.BadLocationException;

/**
 * @author raha
 *
 */
public class path {

	private Graph graph;
	private Node source, sink;
	private int algorithmNumber, maxlength;
	public ArrayList<Node> nodeList;
	public ArrayList<Node> nodeList1;
	private ArrayList<Edge> edgeList;
	public int help = 0;
	private ArrayList<Integer> copyresult;
	private ArrayList<ArrayList<Integer>> allPathes;
	private ArrayList<ArrayList<Integer>> allSecondPathes;
	
	private boolean continueSearch = true;
	private int sizeOdShortestPath = 99999;
	private int sizeOdSecondShortestPath;

	private ArrayList<Integer> current;

	a shortpath;
	a suboptimalpath;
	a allpath;

	public path(Graph g, int algorithmNumber, int maxlength) {
		super();

		this.graph = g;
		this.algorithmNumber = algorithmNumber;
		this.maxlength = maxlength;
		this.nodeList = g.getNode_List();
		this.edgeList = g.getEdges_List();
		this.nodeList1 = g.getNode_List();
		copyresult = new ArrayList<>();
		allPathes = new ArrayList<ArrayList<Integer>>();
		current = new ArrayList<>();
		initial();

	}

	private void initial() {
		int[] temparray1;
		int[] temparray2;
		int[] temparray3;
		temparray1 = graph.getSource();
		temparray2 = graph.getTarget();
		temparray3 = graph.getOfftarget();

		if (algorithmNumber == 1) {
			shortpath = new a();
			shortpath.setTitle("shortest path");
			shortpath.setVisible(true);
			for (int i = 0; i < temparray1.length; i++) {
				source = nodeList.get(temparray1[i]);
				for (int j = 0; j < temparray2.length; j++) {
					sink = nodeList.get(temparray2[j]);
					help = 2;
					shortpath.txt.append("**********************" + "\n");
					shortpath.txt.append("\t" + nodeList.get(source.getHashing_map()).getName() + "->"
							+ nodeList.get(sink.getHashing_map()).getName() + "\n");
					shortestPath();
				}

			}

			for (int i = 0; i < temparray1.length; i++) {
				source = nodeList.get(temparray1[i]);
				for (int j = 0; j < temparray3.length; j++) {
					sink = nodeList.get(temparray3[j]);
					help = 2;
					shortpath.txt.append("**********************" + "\n");
					shortpath.txt.append("\t" + nodeList.get(source.getHashing_map()).getName() + "->"
							+ nodeList.get(sink.getHashing_map()).getName() + "\n");
					shortestPath();
				}

			}
			printAllPathes();

		}
		if (algorithmNumber == 2) {
			suboptimalpath = new a();
			suboptimalpath.setTitle("subOPtimal Pathes");
			suboptimalpath.setVisible(true);
			for (int i = 0; i < temparray1.length; i++) {
				source = graph.getNode_List().get(temparray1[i]);
				for (int j = 0; j < temparray2.length; j++) {
					sink = graph.getNode_List().get(temparray2[j]);
					suboptimalpath.txt.append("**********************" + "\n");
					suboptimalpath.txt.append("\t" + nodeList.get(source.getHashing_map()).getName() + "->"
							+ nodeList.get(sink.getHashing_map()).getName() + "\n");
					shortestPath();
					help = 0;

				}

			}

			for (int i = 0; i < temparray1.length; i++) {
				source = graph.getNode_List().get(temparray1[i]);
				for (int j = 0; j < temparray3.length; j++) {
					sink = graph.getNode_List().get(temparray3[j]);
					suboptimalpath.txt.append("**********************" + "\n");
					suboptimalpath.txt.append("\t" + nodeList.get(source.getHashing_map()).getName() + "->"
							+ nodeList.get(sink.getHashing_map()).getName() + "\n");
					shortestPath();
					help = 0;

				}

			}

		}

		if (algorithmNumber == 3) {
			allpath = new a();
			allpath.setTitle("allpaath");
			allpath.setVisible(true);
			boolean[] visited = new boolean[nodeList.size()];

			for (int i = 0; i < temparray1.length; i++) {
				source = graph.getNode_List().get(temparray1[i]);
				for (int j = 0; j < temparray2.length; j++) {
					sink = graph.getNode_List().get(temparray2[j]);
					for (int i1 = 0; i1 < nodeList.size(); i1++) {
						visited[i1] = false;
					}
					allpath.txt.append("**********************" + "\n");
					allpath.txt.append("\t" + nodeList.get(source.getHashing_map()).getName() + "->"
							+ nodeList.get(sink.getHashing_map()).getName() + "\n");
					findAllPath(source.getHashing_map(), sink.getHashing_map(), visited);
				}

			}

			for (int i = 0; i < temparray1.length; i++) {
				source = graph.getNode_List().get(temparray1[i]);
				for (int j = 0; j < temparray3.length; j++) {
					sink = graph.getNode_List().get(temparray3[j]);
					for (int i1 = 0; i1 < nodeList.size(); i1++) {
						visited[i1] = false;
					}
					allpath.txt.append("**********************" + "\n");

					allpath.txt.append("\t" + nodeList.get(source.getHashing_map()).getName() + "->"
							+ nodeList.get(sink.getHashing_map()).getName() + "\n");

					findAllPath(source.getHashing_map(), sink.getHashing_map(), visited);
				}

			}

		}

	}

	public Node getSource() {
		return source;
	}

	public void setSource(Node source) {
		this.source = source;
	}

	public Node getSink() {
		return sink;
	}

	public void setSink(Node sink) {
		this.sink = sink;
	}

	public int getAlgorithmNumber() {
		return algorithmNumber;
	}

	public void setAlgorithmNumber(int algorithmNumber) {
		this.algorithmNumber = algorithmNumber;
	}

	public void shortestPath() {

		int indexsource, indexsink;

		sizeOdShortestPath = 9999;

		int[] visited = new int[nodeList1.size()];

		for (int i = 0; i < visited.length; i++) {

			visited[i] = 0;
		}

		current = new ArrayList<>();

		indexsource = source.getHashing_map();
		indexsink = sink.getHashing_map();

		visited[indexsource] = 1;
		current.add(indexsource);

		int pp = 0;
		int casestop = 0;

		int indexcurrent = 0;

		int t = 0;

		int index = 0;

		int tt = 0;


		while (tt == 0) {

			t = 0;

			while (t == 0 ) {

				indexcurrent = current.get(current.size() - 1);
				pp++;

				if (indexcurrent == indexsink) {

					casestop = 1;
					t = 1;

					if (current.size() < sizeOdShortestPath) {

						sizeOdShortestPath = current.size();

						allPathes.clear();

						allPathes.add(current);

						printAllPathes();
					} else {
						allPathes.add(current);

						printAllPathes();
					}
					break;
				}
				t = 1;

				for (int j = 0; j < nodeList.get(current.get(current.size() - 1)).getNeighborHashing().size(); j++) {

					if (visited[nodeList.get(current.get(current.size() - 1)).getNeighborHashing().get(j)] == 0) {

						t = 0;

						visited[nodeList.get(current.get(current.size() - 1)).getNeighborHashing().get(j)] = 1;

						current.add(nodeList.get(current.get(current.size() - 1)).getNeighborHashing().get(j));

						break;
					}
					
				}
				

				if (t == 1 & current.size() > 1) {
					
					visited[current.get(current.size() - 1)] = 1;

					current.add(current.get(current.size() - 1));	

					casestop = 3;

				}
				

				if (current.size() > sizeOdShortestPath) {

					t = 1;

					casestop = 2;

				}

			}


			if (current.size() <3) {

				tt = 1;
				break;

			}

			visited[current.get(current.size() - 1)] = 0;

			current.remove(current.size() - 1);

			index = nodeList.get(current.get(current.size() - 2)).getNeighborHashing()
					.indexOf(current.get(current.size() - 1));
			
			visited[current.get(current.size() - 1)] = 0;

			current.remove(current.size() - 1);

			int z = 0;
			int zz = 0;
			int index11=0;

			while (true) {
				zz = 0;
				z = 0;
				for (int i = index +1 ; i < nodeList.get(current.get(current.size() - 1)).getNeighborHashing()
						.size(); i++) {

					if (visited[nodeList.get(current.get(current.size() - 1)).getNeighborHashing().get(i)] == 0){

						z = 1;
						index11 = i;	
						break;
					}
				}
				
				if(z == 1){
	
					break;
				}
				
								
				if (current.size() == 1) {

					tt = 1;

					break;
				}
				index = nodeList.get(current.get(current.size() - 2)).getNeighborHashing()
						.indexOf(current.get(current.size() - 1));
		
				visited[current.get(current.size() - 1)] = 0;

				current.remove(current.size() - 1);

			}
			
			if (tt == 1 )
				break;
			
			if(z == 1){
				visited[nodeList.get(current.get(current.size() - 1)).getNeighborHashing().get(index11)] = 1;
				current.add(nodeList.get(current.get(current.size() - 1)).getNeighborHashing().get(index11));
				
			}
		}
		
	}
	
	public void SubOptimal() {

		int indexsource, indexsink;

		sizeOdShortestPath = 9999;
		sizeOdSecondShortestPath = 9999;

		int[] visited = new int[nodeList1.size()];

		for (int i = 0; i < visited.length; i++) {

			visited[i] = 0;
		}

		current = new ArrayList<>();

		indexsource = source.getHashing_map();
		indexsink = sink.getHashing_map();

		visited[indexsource] = 1;
		current.add(indexsource);

		int pp = 0;
		int casestop = 0;

		int indexcurrent = 0;

		int t = 0;

		int index = 0;

		int tt = 0;


		while (tt == 0) {

			t = 0;

			while (t == 0 ) {

				indexcurrent = current.get(current.size() - 1);
				pp++;

				if (indexcurrent == indexsink) {

					casestop = 1;
					t = 1;

					if (current.size() < sizeOdShortestPath) {
						
						sizeOdSecondShortestPath =sizeOdShortestPath;
						
						sizeOdShortestPath = current.size();
						
						allSecondPathes = allPathes;

						allPathes.clear();

						allPathes.add(current);

						printAllPathes();
					} 
					if(current.size() > sizeOdShortestPath & current.size() < sizeOdSecondShortestPath){
						
						sizeOdSecondShortestPath =current.size();
						
						allSecondPathes.clear();
						
						allSecondPathes.add(current);
						
						printAllPathes();
						
					}

				break;	
				}
				t = 1;

				for (int j = 0; j < nodeList.get(current.get(current.size() - 1)).getNeighborHashing().size(); j++) {

					if (visited[nodeList.get(current.get(current.size() - 1)).getNeighborHashing().get(j)] == 0) {

						t = 0;

						visited[nodeList.get(current.get(current.size() - 1)).getNeighborHashing().get(j)] = 1;

						current.add(nodeList.get(current.get(current.size() - 1)).getNeighborHashing().get(j));

						break;
					}
					
				}
				

				if (t == 1 & current.size() > 1) {
					
					visited[current.get(current.size() - 1)] = 1;

					current.add(current.get(current.size() - 1));	

					casestop = 3;

				}
				

				if (current.size() > sizeOdSecondShortestPath) {

					t = 1;

					casestop = 2;

				}

			}


			if (current.size() <3) {

				tt = 1;
				break;

			}

			visited[current.get(current.size() - 1)] = 0;

			current.remove(current.size() - 1);

			index = nodeList.get(current.get(current.size() - 2)).getNeighborHashing()
					.indexOf(current.get(current.size() - 1));
			
			visited[current.get(current.size() - 1)] = 0;

			current.remove(current.size() - 1);

			int z = 0;
			int zz = 0;
			int index11=0;

			while (true) {
				zz = 0;
				z = 0;
				for (int i = index +1 ; i < nodeList.get(current.get(current.size() - 1)).getNeighborHashing()
						.size(); i++) {

					if (visited[nodeList.get(current.get(current.size() - 1)).getNeighborHashing().get(i)] == 0){

						z = 1;
						index11 = i;	
						break;
					}
				}
				
				if(z == 1){
	
					break;
				}
				
								
				if (current.size() == 1) {

					tt = 1;

					break;
				}
				index = nodeList.get(current.get(current.size() - 2)).getNeighborHashing()
						.indexOf(current.get(current.size() - 1));
		
				visited[current.get(current.size() - 1)] = 0;

				current.remove(current.size() - 1);

			}
			
			if (tt == 1 )
				break;
			
			if(z == 1){
				visited[nodeList.get(current.get(current.size() - 1)).getNeighborHashing().get(index11)] = 1;
				current.add(nodeList.get(current.get(current.size() - 1)).getNeighborHashing().get(index11));
				
			}
		}
		
	}

			

	Stack<Integer> stack = new Stack<Integer>();

	public void findAllPath(int s, int d, boolean[] visited) {
		// allpath.txt.append(s + " " +nodeList.get(s).getName() );
		stack.add(s);

		if (s == d) {
			printStack(stack, 3);
		}

		if (visited[s] != true)
			visited[s] = true;

		ArrayList<Integer> adjNodes = new ArrayList<>();
		adjNodes = nodeList.get(s).getNeighborHashing(); // getAdjacentNodes(s);

		// if (adjNodes.size() > 0 & stack.size()<maxlength) {
		if (adjNodes.size() > 0) {
			for (int i = 0; i < adjNodes.size(); i++) {
				if (visited[adjNodes.get(i)] != true) {
					// allpath.txt.append( "
					// "+nodeList.get(adjNodes.get(i)).getCanonicalName());
					findAllPath(adjNodes.get(i), d, visited);
				}
			}
		}

		visited[s] = false;
		stack.remove(stack.size() - 1);
	}

	private void printStack(Stack<Integer> stack, int type) {

		if (type == 3) {

			allpath.txt.append("\n");
			for (int i = 0; i < stack.size(); i++)
				allpath.txt.append(nodeList.get(stack.get(i)).getName() + "->");

			allpath.txt.append("\n");

		}

		if (type == 1) {

			for (int i = 0; i < stack.size(); i++)
				shortpath.txt.append(nodeList.get(stack.get(i)).getName() + "->");
			shortpath.txt.append("\n");
		}
		if (type == 2) {

			for (int i = 0; i < stack.size(); i++)
				suboptimalpath.txt.append(nodeList.get(stack.get(i)).getName() + "->");
			suboptimalpath.txt.append("\n");

		}
	}

	private void printAllPathes() {

		// shortpath.txt.append(allPathes.size()+ "\n");
		// for (int i = 0; i < allPathes.size(); i++) {
		for (int j = 0; j < allPathes.get(0).size(); j++)
			shortpath.txt.append(nodeList.get(allPathes.get(0).get(j)).getName() + "->");
		shortpath.txt.append("\n");

		// }

	}

	public void pr(ArrayList<Integer> a, int i) {

		for (int j = 0; j < a.size(); j++) {

			shortpath.txt.append(nodeList.get(a.get(j)).getName() + "  ");

		}
		shortpath.txt.append(i + "\n\n");

	}
}
v
