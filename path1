/**
 * 
 */
package org.cytoscape.myapp.internal;

import java.awt.List;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Vector;

import javax.swing.text.BadLocationException;

/**
 * @author raha
 *
 */
public class path {

	private Graph graph;
	private Node source, sink;
	private int algorithmNumber, maxlength;
	public ArrayList<Node> nodeList;
	public ArrayList<Node> nodeList1;
	private ArrayList<Edge> edgeList;
	public int help = 0;
	private ArrayList<Integer> copyresult;
	private ArrayList<ArrayList<Integer>> allPathes;
	private boolean continueSearch = true;
	private int sizeOdShortestPath = 99999;

	a shortpath;
	a suboptimalpath;
	a allpath;

	public path(Graph g, int algorithmNumber, int maxlength) {
		super();

		this.graph = g;
		this.algorithmNumber = algorithmNumber;
		this.maxlength = maxlength;
		this.nodeList = g.getNode_List();
		this.edgeList = g.getEdges_List();
		this.nodeList1 = g.getNode_List();
		copyresult = new ArrayList<>();
		allPathes = new ArrayList<ArrayList<Integer>>();
		initial();

	}

	private void initial() {
		int[] temparray1;
		int[] temparray2;
		int[] temparray3;
		temparray1 = graph.getSource();
		temparray2 = graph.getTarget();
		temparray3 = graph.getOfftarget();

		if (algorithmNumber == 1) {
			shortpath = new a();
			shortpath.setTitle("shortest path");
			shortpath.setVisible(true);
			for (int i = 0; i < temparray1.length; i++) {
				source = nodeList.get(temparray1[i]);
				for (int j = 0; j < temparray2.length; j++) {
					sink = nodeList.get(temparray2[j]);
					help = 2;
					shortpath.jTextArea1.append("**********************" + "\n");
					shortpath.jTextArea1.append("\t" + nodeList.get(source.getHashing_map()).getName() + "->"
							+ nodeList.get(sink.getHashing_map()).getName() + "\n");
					shortestPath();
				}

			}

			for (int i = 0; i < temparray1.length; i++) {
				source = nodeList.get(temparray1[i]);
				for (int j = 0; j < temparray3.length; j++) {
					sink = nodeList.get(temparray3[j]);
					help = 2;
					shortpath.jTextArea1.append("**********************" + "\n");
					shortpath.jTextArea1.append("\t" + nodeList.get(source.getHashing_map()).getName() + "->"
							+ nodeList.get(sink.getHashing_map()).getName() + "\n");
					shortestPath();
				}

			}
			printAllPathes();

		}
		if (algorithmNumber == 2) {
			suboptimalpath = new a();
			suboptimalpath.setTitle("subOPtimal Pathes");
			suboptimalpath.setVisible(true);
			for (int i = 0; i < temparray1.length; i++) {
				source = graph.getNode_List().get(temparray1[i]);
				for (int j = 0; j < temparray2.length; j++) {
					sink = graph.getNode_List().get(temparray2[j]);
					suboptimalpath.jTextArea1.append("**********************" + "\n");
					suboptimalpath.jTextArea1.append("\t" + nodeList.get(source.getHashing_map()).getName() + "->"
							+ nodeList.get(sink.getHashing_map()).getName() + "\n");
					shortestPath();
					help = 0;

				}

			}

			for (int i = 0; i < temparray1.length; i++) {
				source = graph.getNode_List().get(temparray1[i]);
				for (int j = 0; j < temparray3.length; j++) {
					sink = graph.getNode_List().get(temparray3[j]);
					suboptimalpath.jTextArea1.append("**********************" + "\n");
					suboptimalpath.jTextArea1.append("\t" + nodeList.get(source.getHashing_map()).getName() + "->"
							+ nodeList.get(sink.getHashing_map()).getName() + "\n");
					shortestPath();
					help = 0;

				}

			}

		}

		if (algorithmNumber == 3) {
			allpath = new a();
			allpath.setTitle("allpaath");
			allpath.setVisible(true);
			boolean[] visited = new boolean[nodeList.size()];

			for (int i = 0; i < temparray1.length; i++) {
				source = graph.getNode_List().get(temparray1[i]);
				for (int j = 0; j < temparray2.length; j++) {
					sink = graph.getNode_List().get(temparray2[j]);
					for (int i1 = 0; i1 < nodeList.size(); i1++) {
						visited[i1] = false;
					}
					allpath.jTextArea1.append("**********************" + "\n");
					allpath.jTextArea1.append("\t" + nodeList.get(source.getHashing_map()).getName() + "->"
							+ nodeList.get(sink.getHashing_map()).getName() + "\n");
					findAllPath(source.getHashing_map(), sink.getHashing_map(), visited);
				}

			}

			for (int i = 0; i < temparray1.length; i++) {
				source = graph.getNode_List().get(temparray1[i]);
				for (int j = 0; j < temparray3.length; j++) {
					sink = graph.getNode_List().get(temparray3[j]);
					for (int i1 = 0; i1 < nodeList.size(); i1++) {
						visited[i1] = false;
					}
					allpath.jTextArea1.append("**********************" + "\n");

					allpath.jTextArea1.append("\t" + nodeList.get(source.getHashing_map()).getName() + "->"
							+ nodeList.get(sink.getHashing_map()).getName() + "\n");

					findAllPath(source.getHashing_map(), sink.getHashing_map(), visited);
				}

			}

		}

	}

	public Node getSource() {
		return source;
	}

	public void setSource(Node source) {
		this.source = source;
	}

	public Node getSink() {
		return sink;
	}

	public void setSink(Node sink) {
		this.sink = sink;
	}

	public int getAlgorithmNumber() {
		return algorithmNumber;
	}

	public void setAlgorithmNumber(int algorithmNumber) {
		this.algorithmNumber = algorithmNumber;
	}

	public void shortestPath() {

		int indexsource, indexsink;

		sizeOdShortestPath = 9999;

		int[] visited = new int[nodeList1.size()];

		for (int i = 0; i < visited.length; i++) {

			visited[i] = 0;
		}

		ArrayList<Integer> current = new ArrayList<>();

		indexsource = source.getHashing_map();
		indexsink = sink.getHashing_map();

		visited[indexsource] = 1;
		current.add(indexsource);

		int t = 0;

		int index = 0;
		
		shortpath.jTextArea1.append("mmmmmmmmmmmmm"+current.size() + "  " + index + "   "
				+ nodeList.get(current.get(current.size() - 1)).getName() + "\n");


		if (indexsource == indexsink) {

			allPathes.add(current);

		} else {

			shortpath.jTextArea1.append("mmmmmmmmmmmmm"+current.size() + "  " + index + "   "
					+ nodeList.get(current.get(current.size() - 1)).getName() + "\n");
			current.add(nodeList.get(indexsource).getNeighborHashing().get(0));

			visited[nodeList.get(indexsource).getNeighborHashing().get(0)] = 1;

			while (current.size() > 0) {

				shortpath.jTextArea1.append("mmmmmmmmmmmmm"+current.size() + "  " + index + "   "
						+ nodeList.get(current.get(current.size() - 1)).getName() + "\n");

				while (current.size() < sizeOdShortestPath) {

					shortpath.jTextArea1.append(current.size() + "  " + index + "   "
							+ nodeList.get(current.get(current.size() - 1)).getName() + "\n");

					if (current.get(current.size() - 1) == indexsink) {

						shortpath.jTextArea1.append("***************\n");

						if (current.size() < sizeOdShortestPath) {

							sizeOdShortestPath = current.size();

							allPathes.clear();

							allPathes.add(current);

							printAllPathes();

							t = 1;

						} else {

							allPathes.add(current);
						}

					}

					if (t == 0) {

						current.add(nodeList.get(indexsource).getNeighborHashing().get(0));

						visited[current.size() - 1] = 0;

						current.remove(current.size() - 1);
					} else {

						visited[current.size() - 1] = 0;

						current.remove(current.size() - 1);

						t = 0;

						break;
					}

				}

				if (current.size() > 100) {

					index = nodeList.get(current.get(current.size() - 2)).getNeighborHashing()
							.indexOf(current.get(current.size() - 1));

					shortpath.jTextArea1.append(current.size() + "  " + index + "   "
							+ nodeList.get(current.get(current.size() - 1)).getName() + "\n");

					while (nodeList.get(current.get(current.size() - 2)).getNeighborHashing().size() == index) {

						current.remove(current.size() - 1);

						index = nodeList.get(current.get(current.size() - 2)).getNeighborHashing()
								.indexOf(current.get(current.size() - 1));

					}

					visited[current.size() - 1] = 0;

					current.remove(current.size() - 1);

					current.add(nodeList.get(current.size() - 1).getNeighborHashing().get(index + 1));

					visited[nodeList.get(current.size() - 1).getNeighborHashing().get(index + 1)] = 1;
				} else

					current.remove(0);

			}

		}

	}
	/*
	 * 
	 * shortpath.jTextArea1.append(sizeOdShortestPath + "  "+
	 * currentLength[current.get(0)]+ "   "+
	 * nodeList.get(nodeList.get(current.get(0)).getNeighborHashing().get(i)).
	 * getName()+"\n");
	 * 
	 * if ((currentLength[current.get(0)] <sizeOdShortestPath) &
	 * visited[nodeList.get(current.get(0)).getNeighborHashing().get(i)] == 0 &
	 * (copyresult.indexOf(current.get(0)) + 1 != copyresult
	 * .indexOf(nodeList.get(current.get(0)).getNeighborHashing().get(i)))) {
	 * 
	 * visited[nodeList.get(current.get(0)).getNeighborHashing().get(i)] = 1;
	 * currentLength[nodeList.get(current.get(0)).getNeighborHashing().get(i)] =
	 * currentLength[current.get(0)] +1;
	 * previousIndex[nodeList.get(current.get(0)).getNeighborHashing().get(i)] =
	 * current.get(0);
	 * current.add(nodeList.get(current.get(0)).getNeighborHashing().get(i));
	 * 
	 * if (nodeList.get(current.get(0)).getNeighborHashing().get(i) ==
	 * indexsink) {
	 * 
	 * 
	 * 
	 * visited[indexsink] = 0; temp = previousIndex[indexsink];
	 * result.add(indexsink);
	 * 
	 * while (temp != -1) { visited[temp] = 0; result.add(temp); temp =
	 * previousIndex[temp]; } sizeOdShortestPath = result.size()-1;
	 * shortpath.jTextArea1.append(sizeOdShortestPath + "\n");
	 * 
	 * allPathes.add(result); current.remove(current.size()-1);
	 * printAllPathes(); result.clear();
	 * 
	 * } }
	 * 
	 * } current.remove(0); }
	 * 
	 * /*if (previousIndex[indexsink] != -1 || indexsink == indexsource) {
	 * 
	 * temp = previousIndex[indexsink]; result.push(indexsink); while (temp !=
	 * -1) { result.push(temp); temp = previousIndex[temp]; }
	 * allPathes.add(result); }
	 * 
	 * for (int i = 0; i < reversresult.size(); i++)
	 * result.add(reversresult.get(reversresult.size() - i - 1));
	 * 
	 * if (help == 2) printStack(result, 1); else printStack(result, 2);
	 * 
	 * if (copyresult.size() > 0) copyresult.clear(); if (result.size() > 0) for
	 * (int i = 0; i < result.size(); i++) copyresult.add((Integer)
	 * result.get(i));
	 * 
	 * if (help == 0) {
	 * 
	 * help = 1; shortestPath();
	 * 
	 * }
	 */

	Stack<Integer> stack = new Stack<Integer>();

	public void findAllPath(int s, int d, boolean[] visited) {
		// allpath.jTextArea1.append(s + " " +nodeList.get(s).getName() );
		stack.add(s);

		if (s == d) {
			printStack(stack, 3);
		}

		if (visited[s] != true)
			visited[s] = true;

		ArrayList<Integer> adjNodes = new ArrayList<>();
		adjNodes = nodeList.get(s).getNeighborHashing(); // getAdjacentNodes(s);

		// if (adjNodes.size() > 0 & stack.size()<maxlength) {
		if (adjNodes.size() > 0) {
			for (int i = 0; i < adjNodes.size(); i++) {
				if (visited[adjNodes.get(i)] != true) {
					// allpath.jTextArea1.append( "
					// "+nodeList.get(adjNodes.get(i)).getCanonicalName());
					findAllPath(adjNodes.get(i), d, visited);
				}
			}
		}

		visited[s] = false;
		stack.remove(stack.size() - 1);
	}

	private void printStack(Stack<Integer> stack, int type) {

		if (type == 3) {

			allpath.jTextArea1.append("\n");
			for (int i = 0; i < stack.size(); i++)
				allpath.jTextArea1.append(nodeList.get(stack.get(i)).getName() + "->");

			allpath.jTextArea1.append("\n");

		}

		if (type == 1) {

			for (int i = 0; i < stack.size(); i++)
				shortpath.jTextArea1.append(nodeList.get(stack.get(i)).getName() + "->");
			shortpath.jTextArea1.append("\n");
		}
		if (type == 2) {

			for (int i = 0; i < stack.size(); i++)
				suboptimalpath.jTextArea1.append(nodeList.get(stack.get(i)).getName() + "->");
			suboptimalpath.jTextArea1.append("\n");

		}
	}

	private void printAllPathes() {

		// shortpath.jTextArea1.append(allPathes.size()+ "\n");
		for (int i = 0; i < allPathes.size(); i++) {
			for (int j = 0; j < allPathes.get(i).size(); j++)
				shortpath.jTextArea1.append(i + "  " + j + "   "
						+ nodeList.get(allPathes.get(i).get(allPathes.get(i).size() - j - 1)).getName() + "->");
			shortpath.jTextArea1.append("\n");

		}

	}
}
