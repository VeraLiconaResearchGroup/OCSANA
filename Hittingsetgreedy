/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
z

 Question

 For pathes with length 0 like I1 to I1 .what is lrngth ?
 */
package org.cytoscape.myapp.internal;

import java.beans.VetoableChangeListener;
import java.beans.VetoableChangeSupport;
import static java.lang.Math.abs;
import java.util.ArrayList;
import java.util.Arrays;
import static java.util.Collections.list;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Set;
import java.util.Vector;

/**
 *
 * @author raha
 */
public class scorring {

    private Vector<Vector<Integer>> pathes;

    private ArrayList<Node> nodeList;

    private Graph graph;

    private ArrayList<Integer> typeOfEdge;

    private int[] source;

    private int[] target;

    private int[] offtarget;

    private Vector<Integer> elementaryNOdes;
    
    private Vector<Float> ocsanaScore;

    private int X;

    private int Y;

    private int[] x_i;
    
    private int[] setscoreset;

    private int[] y_i;

    private int[] scoreSet;
      
    private int largNumberOfCandidate=99999;
    
    private a scoringGUI;
    
    private int radius=99999;
    
    private int largeCardinality=99999;

    public int[] getScoreSet() {
        return scoreSet;
    }

    public int[] getSource() {
        return source;
    }

    public void setSource() {
        this.source = graph.getSource();
    }

    public int[] getTarget() {
        return target;
    }

    public void setTarget() {
        this.target = graph.getTarget();
    }

    public int[] getOfftarget() {
        return offtarget;
    }

    public void setOfftarget() {
        this.offtarget = graph.getOfftarget();
    }

    public int getLargeCardinality() {
        return largeCardinality;
    }

    public void setLargeCardinality(int largeCardinality) {
        this.largeCardinality = largeCardinality;
    }

    public int getLargNumberOfCandidate() {
        return largNumberOfCandidate;
    }

    public void setLargNumberOfCandidate(int largNumberOfCandidate) {
        this.largNumberOfCandidate = largNumberOfCandidate;
    }

    public int getRadius() {
        return radius;
    }

    public void setRadius(int radius) {
        this.radius = radius;
    }
    
    public scorring(Vector<Vector<Integer>> pathes, Graph graph) {
        this.pathes = pathes;
        this.graph = graph;
        scoringGUI = new a();
        scoringGUI.setTitle("SCORRING");
        scoringGUI.setVisible(true);
        initial();

    }

    /**
     * Get the value of typeOfEdge
     *
     * @return the value of typeOfEdge
     */
    public ArrayList<Integer> getTypeOfEdge() {
        return typeOfEdge;
    }

    /**
     * Set the value of typeOfEdge
     *
     * @param typeOfEdge new value of typeOfEdge
     */
    public void setTypeOfEdge(ArrayList<Integer> typeOfEdge) {
        this.typeOfEdge = typeOfEdge;
    }

    private void initial() {

        
        setNodeList();
        setSource();
        setTarget();
        setOfftarget();
        setElementaryNOdes();  
        printfinalresult(pathes);
        setX_i();
         scoringGUI.txt.append( "1 \n   ");
        setY_i(); 
        scoringGUI.txt.append( "2 \n   ");
        setX();
        scoringGUI.txt.append( "3 \n   ");
        setY();
        scoringGUI.txt.append( "4 \n   ");
        
        setscoreset =  new int[nodeList.size()];
        for (int i = 0; i < setscoreset.length; i++) {
           setscoreset[i]  = 0;
            
        }
      scoringGUI.txt.append( "5 \n   ");
       printArray(x_i, "x_i");
       printArray(y_i, "y_i");
       
       
       scoringGUI.txt.append(" X is :  "  +X+ "\n");
        scoringGUI.txt.append("\n******************************************************************\n");  
       scoringGUI.txt.append(" Y is :  "  +Y+ "\n");
        scoringGUI.txt.append("\n******************************************************************\n");  
        
       initialScoreSe();
       // scoreSet = new int[elementaryNOdes.size()];
       // for (int i = 0; i < elementaryNOdes.size(); i++) {
       //     scoreSet[i] = 0;
       // }
         CI();
         
         hittingSetGreedyAlgorithm a = new hittingSetGreedyAlgorithm(source, target, offtarget, pathes, radius, largeCardinality, largNumberOfCandidate, ocsanaScore,setscoreset, elementaryNOdes,nodeList);

    }
    
     /**
     * Set the value of nodeList
     *
     * @param nodeList new value of nodeList
     */
    public void setNodeList() {
        this.nodeList = graph.getNode_List();
    }
    
     /**
     * Get the value of nodeList
     *
     * @return the value of nodeList
     */
    public ArrayList<Node> getNodeList() {
        ArrayList<Node> nodeList = null;
        return nodeList;
    }

    /**
     * Get the value of graph
     *
     * @return the value of graph
     */
    public Graph getGraph() {
        return graph;
    }

    /**
     * Set the value of graph
     *
     * @param graph new value of graph
     */
    public void setGraph(Graph graph) {
        this.graph = graph;
    }

    public Vector<Integer> getElementaryNOdes() {
        return elementaryNOdes;
    }

    public Vector<Vector<Integer>> getPathes() {
        return pathes;
    }
    
    public void setElementaryNOdes() {

        this.elementaryNOdes = new Vector();

        for (int j = 0; j < nodeList.size(); j++) {

            for (int i = 0; i < pathes.size(); i++) {

                if (pathes.get(i).size() > 1) {

                    if (pathes.get(i).contains(nodeList.get(j).getHashing_map())) {

                        elementaryNOdes.add(nodeList.get(j).getHashing_map());

                        break;
                    }
                }
            }
        }

        scoringGUI.txt.append("******************************************************************\n  "
                + "             elementary Nose \n ******************************************************************\n");
        for (int i = 0; i < elementaryNOdes.size(); i++) {
            scoringGUI.txt.append(nodeList.get(elementaryNOdes.get(i)).getName() + "    ");
        }
        scoringGUI.txt.append("\n******************************************************************\n \n ");
    }

    public void initialScoreSe(){
    scoreSet = new int[elementaryNOdes.size()];
        for (int i = 0; i < elementaryNOdes.size(); i++) {
            scoreSet[i] = 0;
        }
    }
    public int  setScoreSet(int v_i) {

        scoringGUI.txt.append("   ***************************************** \n  setScoreSet \n************************************** \n");
            int score = 0;   
            for (int j = 0; j < pathes.size(); j++) {
 scoringGUI.txt.append( "     pathes  " + j+ "  :  " );
                printfinalresult1(pathes.get(j));
                int[] target = getTarget();
                int t = 0;
                for (int k = 0; k < target.length; k++) {
                    if (target[k] == pathes.get(j).get(pathes.get(j).size() - 1)) {
                        t = 1;
                        break;
                    }
                }
                if (t == 1) {                
                    if (pathes.get(j).contains(v_i)) {
                        score ++;                    
                    }
                }
            }
            scoringGUI.txt.append(nodeList.get(v_i).getName() + "      scoreSet[i]  " + "    " + score + " \n   ");
            setscoreset[v_i] = score;
        return score;
    }

    /**
     * Set the value of pathes
     *
     * @param pathes new value of pathes
     */
    public void setPathes(Vector<Vector<Integer>> pathes) {
        this.pathes = pathes;
    }

    private int lengthOfPath(Vector<Integer> path, int elementaryNode) {

        int lengthOfPath = 0;

        lengthOfPath = path.size() - path.indexOf(elementaryNode) - 1;

        return lengthOfPath;

    }

    private int signOfPath(Vector< Integer> path, int elementaryNode) {

        int signOfPath = 1;

        int signOfEdge = 1;

        int nodeHashingNumber;

        int indexElementaryNode;

        indexElementaryNode = path.indexOf(elementaryNode);

        for (int i = indexElementaryNode; i < path.size() - 1; i++) {

            nodeHashingNumber = path.get(i);

            for (int j = 0; j < nodeList.get(nodeHashingNumber).getNeighborHashing().size(); j++) {

                if (nodeList.get(nodeHashingNumber).getNeighborHashing().get(j) == path.get(i + 1)) {

                    signOfEdge = nodeList.get(nodeHashingNumber).getTypeOfEdge().get(j);
                    signOfPath = signOfPath * signOfEdge;
                    break;
                }
            }
        }
        return signOfPath;
    }

    private Vector<Vector<Integer>> allPath(int elementaryNode, int sinkId) {

        //scoringGUI.txt.append("allPath: \n pathes \n  " + pathes + "\n");
        printfinalresult(pathes);

        Vector<Vector<Integer>> allPath = new Vector<>();

        for (int i = 0; i < pathes.size(); i++) {

            if (pathes.get(i).contains(elementaryNode) & pathes.get(i).get(pathes.get(i).size() - 1) == sinkId) {
                allPath.add(pathes.get(i));
            }
        }
        return allPath;
    }

    private float effectOnTarget(int elementaryNode, int sinkId) {

        int numberOfPath = 0;

        float effectOnTarget = 0;

        Vector<Vector<Integer>> allPathes = new Vector<>();

        allPathes = allPath(elementaryNode, sinkId);

        scoringGUI.txt.append("\n ******************************************************************\n  "
                + "             effectOnTarget \n ******************************************************************\n");

        scoringGUI.txt.append("\n elementaryNode:   " + nodeList.get(elementaryNode).getName() + "  sinkId:    " + nodeList.get(sinkId).getName() + "\n");
       // scoringGUI.txt.append("\n allPathes \n  " + allPathes + "\n");
        printfinalresult(allPathes);

        numberOfPath = allPathes.size();

        for (int i = 0; i < numberOfPath; i++) {

            if (elementaryNode != sinkId) {

                //scoringGUI.txt.append("allPathes " + i + "  : " + allPathes.get(i) + "\t");
                printfinalresult1(allPathes.get(i));

                scoringGUI.txt.append("lengthOfPath:  " + lengthOfPath(allPathes.get(i), elementaryNode) + "\t");

                scoringGUI.txt.append("signOfPath:  " + (float) signOfPath(allPathes.get(i), elementaryNode) + "\n");

               
                effectOnTarget = effectOnTarget + (float) ((float) (1 / (float) lengthOfPath(allPathes.get(i), elementaryNode))) * signOfPath(allPathes.get(i), elementaryNode);
            }
        }

        scoringGUI.txt.append("effectOnTarget :  " + effectOnTarget + "\n");
        return effectOnTarget;
    }

    private float effectOfTargets(int elementaryNode) {

        float effectOfTargets = 0;

        int[] target = getTarget();

        for (int i = 0; i < target.length; i++) {

            effectOfTargets = effectOfTargets + effectOnTarget(elementaryNode, target[i]);
        }
scoringGUI.txt.append("effectOfTargets :  "  + effectOfTargets+"\n");
        return effectOfTargets;
    }

    private float sideEffects(int sourceId) {
        
       

        float effectOfTargets = 0;

        int[] oftarget = getOfftarget();

        for (int i = 0; i < oftarget.length; i++) {

            effectOfTargets = abs(effectOnTarget(sourceId, oftarget[i])) + effectOfTargets;
        }
            scoringGUI.txt.append("sideEffects :  "  + effectOfTargets+ "\n");
        return effectOfTargets;
    }

    public int getX() {
        return X;
    }

    public int setX() {

        int x = 0;
        List<Integer> al = new ArrayList<>();

        for (int i = 0; i < pathes.size(); i++) {

            al.add(pathes.get(i).get(pathes.get(i).size() - 1));

        }

        Set<Integer> hs = new HashSet<>();

        hs.addAll(al);
        for (int i = 0; i < graph.getTarget().length; i++) {
            if (hs.contains(graph.getTarget()[i])) {
                x++;
            }
        }
        X = x;
        //scoringGUI.txt.append("X is:  " + x + "  \n  ");
        
        return x;
    }

    public int getY() {
        return Y;
    }

    public int setY() {

        int x = 0;
        List<Integer> al = new ArrayList<>();

        for (int i = 0; i < pathes.size(); i++) {

            al.add(pathes.get(i).get(pathes.get(i).size() - 1));

        }

        Set<Integer> hs = new HashSet<>();

        hs.addAll(al);

        for (int i = 0; i < graph.getOfftarget().length; i++) {
            if (hs.contains(graph.getOfftarget()[i])) {
                x++;
            }
        }
        Y = x;
       // scoringGUI.txt.append("Y is:  " + Y + "  \n  ");
return Y;
    }

    public int[] getX_i() {
        return x_i;
    }

    public int setX_i() {

        x_i = new int[elementaryNOdes.size()];
        int x = 0 ;

        for (int i = 0; i < elementaryNOdes.size(); i++) {

            List<Integer> al = new ArrayList<>();
             x = 0;
            x_i[i] = 0;

            for (int j = 0; j < pathes.size(); j++) {

                if (pathes.get(j).contains(elementaryNOdes.get(i))) {
                    al.add(pathes.get(j).get(pathes.get(j).size() - 1));
                }
            }
            Set<Integer> hs = new HashSet<>();

            hs.addAll(al);

            for (int l = 0; l < graph.getTarget().length; l++) {

                if (hs.contains(graph.getTarget()[l])) {
                    x++;
                }
            }
            x_i[i] = x;
           // scoringGUI.txt.append(nodeList.get(elementaryNOdes.get(i)).getName() + "     x_i" + "    " + x + " \n   ");
        }
return  x;
    }

    public int[] getY_i() {
        return y_i;
    }

    public int setY_i() {

        y_i = new int[elementaryNOdes.size()];
        int y = 0;

        for (int i = 0; i < elementaryNOdes.size(); i++) {

            List<Integer> al = new ArrayList<>();
             y = 0;
            y_i[i] = 0;

            for (int j = 0; j < pathes.size(); j++) {

                if (pathes.get(j).contains(elementaryNOdes.get(i))) {
                    al.add(pathes.get(j).get(pathes.get(j).size() - 1));
                }
            }
            Set<Integer> hs = new HashSet<>();

            hs.addAll(al);

            for (int l = 0; l < graph.getOfftarget().length; l++) {

                if (hs.contains(graph.getOfftarget()[l])) {
                    y++;
                }
            }
            y_i[i] = y;
           // scoringGUI.txt.append(nodeList.get(elementaryNOdes.get(i)).getName() + "     y_i" + "    " + y + " \n   ");
        }
        return y;
    }
   
    private float overAllScore(int v_i) {
        
         

        float overAllScor = 0;

        float firstTerm = 0;

        float secondTerm = 0;
         scoringGUI.txt.append("x_i[v_i] is : " + x_i[v_i] + "\n");
         
         scoringGUI.txt.append("y_i[v_i] is : " + y_i[v_i] + "\n");
         scoringGUI.txt.append("X is : " +X + "\n");
         
         scoringGUI.txt.append("Y is : " + Y + "\n");
        
          
           scoringGUI.txt.append("effectOfTargets is : " + "\n");
         
         

        firstTerm = (float) (x_i[v_i] / (float)X) * (float) abs(effectOfTargets(v_i));
        
        scoringGUI.txt.append("sideEffects is : " + "\n");

        secondTerm = (float) (y_i[v_i] / (float)Y) * (float) abs(sideEffects(v_i));
        
         scoringGUI.txt.append("\n firstTerm  " + firstTerm + "\n");
       
        scoringGUI.txt.append("\n secondTerm  " + secondTerm + "\n");

        if (firstTerm > secondTerm) {

            overAllScor = firstTerm - secondTerm;
        }
        scoringGUI.txt.append("\n overAllScore  " + overAllScor + "\n");

        return overAllScor;
    }

    private float ocsanaScore(int v_i) {
        float ocsanaScore = 0,temp1 = 0 , temp2 = 0;
         scoringGUI.txt.append("overAllScore is:  " +  "\n");
         temp1 = overAllScore(v_i);
         
         scoringGUI.txt.append("setScoreSet is :  " + "\n");
         temp2 = (float)setScoreSet(v_i);

        ocsanaScore = temp1 *temp2;
        
        scoringGUI.txt.append("ocsanaScore is :  " +ocsanaScore + "\n");
        return ocsanaScore;
    }

    private float CI() {
        
        scoringGUI.txt.append("\t CI  " +  "\n");

        float CI = 0;
        
        float temp = 0;
        
        ocsanaScore = new Vector<>();

        for (int i = 0; i < elementaryNOdes.size(); i++) {
              
            scoringGUI.txt.append("Node  " + nodeList.get(elementaryNOdes.get(i)).getName()+" \n");
            scoringGUI.txt.append("ocsanaScore :  " + "\n");
            
            temp = ocsanaScore(elementaryNOdes.get(i));
            ocsanaScore.add(temp);
            
            CI = CI + temp;
            scoringGUI.txt.append("CI  " + CI+ "\n");
        }
        scoringGUI.txt.append("CI  " + CI+ "\n");
        return CI;
    }
    
    public void printfinalresult(Vector<Vector<Integer>> finalresult) {
                    scoringGUI.txt.append("\n******************************************************************\n");
                 scoringGUI.txt.append("\t"+"pathes \n");
                 scoringGUI.txt.append("******************************************************************\n");
                for (int j = 0; j < finalresult.size(); j++) {
                    Vector<Integer> get1 = finalresult.get(j);
                               
                    for (int k = 1; k < get1.size()-1; k++) {
                        
                        scoringGUI.txt.append(nodeList.get(get1.get(k)).getName());
                       int index =  nodeList.get(get1.get(k)).getNeighborHashing().indexOf(get1.get(k+1));
                       if(nodeList.get(get1.get(k)).getTypeOfEdge().get(index) == 1)
                           scoringGUI.txt.append("--->");
                       else
                           scoringGUI.txt.append("---|");
                    }
                  
                    
                    scoringGUI.txt.append(nodeList.get(get1.get(get1.size()-1)).getName()+"\n");
                 
             }
                
              scoringGUI.txt.append("******************************************************************\n  ");  
       }
    
     public void printfinalresult1(Vector<Integer> finalresult) {
                    
                scoringGUI.txt.append("\n******************************************************************\n");  
                 
                    Vector<Integer> get1 = finalresult;
                               
                    for (int k = 1; k < get1.size()-1; k++) {
                        
                        scoringGUI.txt.append(nodeList.get(get1.get(k)).getName());
                       int index =  nodeList.get(get1.get(k)).getNeighborHashing().indexOf(get1.get(k+1));
                       if(nodeList.get(get1.get(k)).getTypeOfEdge().get(index) == 1)
                           scoringGUI.txt.append("--->");
                       else
                           scoringGUI.txt.append("---|");
                    }
                  
                    
                    scoringGUI.txt.append(nodeList.get(get1.get(get1.size()-1)).getName()+"\n");
                 
             //}
                
             
       }
    
    public void printArray(int[] array, String s){
        scoringGUI.txt.append("\n******************************************************************\n");
        scoringGUI.txt.append( "\t"+s +"    is: \n");   
        scoringGUI.txt.append("******************************************************************\n");
        for (int i = 0; i < array.length; i++) {
            int b = array[i];
            
            scoringGUI.txt.append(nodeList.get(i).getName() + "   "+ ":  "+ b + "\n");       
        }  
        
        scoringGUI.txt.append("******************************************************************\n");
    }

}
