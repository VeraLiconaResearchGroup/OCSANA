/*
 * Copyright (C) 2015 misagh.kordi
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package org.cytoscape.myapp.internal;

import java.util.ArrayList;
import java.util.Stack;
import java.util.Vector;

/**
 *
 * @author misagh.kordi
 */
public class hittingSetGreedyAlgorithm {

    private int[] source;

    private int[] target;

    private int[] offtarget;

    private Float inputArr[];

    private ArrayList<Node> nodeList;

    private Vector<Vector<Integer>> pathes;

    private Vector<Vector<Integer>> result;

    private Vector<Vector<Integer>> elementarypathes;

    private int radius;

    public Vector<Vector<Integer>> getElementarypathes() {
        return elementarypathes;
    }

    private int largeCardinality;

    private int largNumberOfCandidate;

    private Vector<Float> ocsanaScore;

    private Vector<Integer> elementaryNOdes;

    private Float[] array;

    private int length;

    private int[] setscoreset;

    private int[][] elementryPathArray;

    private a hittingsetGreedyGUI;

    public hittingSetGreedyAlgorithm(int[] source, int[] target, int[] offtarget, Vector<Vector<Integer>> pathes, int radius, int largeCardinality, int largNumberOfCandidate, Vector<Float> ocsanaScore, int[] setscoreset, Vector<Integer> elementaryNOdes, ArrayList<Node> nodeList) {
        this.source = source;
        this.target = target;
        this.offtarget = offtarget;
        this.pathes = pathes;
        this.radius = radius;
        this.largeCardinality = largeCardinality;
        this.largNumberOfCandidate = largNumberOfCandidate;
        this.ocsanaScore = ocsanaScore;
        this.elementaryNOdes = elementaryNOdes;
        this.nodeList = nodeList;
        this.setscoreset = setscoreset;
        hittingsetGreedyGUI = new a();
        hittingsetGreedyGUI.setTitle("hittingsetGreedyGUI");
        hittingsetGreedyGUI.setVisible(true);

        printArray(source, "source");
        printArray(target, "target");
        printArray(offtarget, "offtarget");
        printfinalresult(pathes);

        printfinalresult2(ocsanaScore);
        printfinalresult3(setscoreset);
        printfinalresult4(elementaryNOdes);
        result = new Vector<>();
        //printfinalresult1(elementaryNOdes);
        initial();
    }

    private void initial() {

        sort();
        printfinalresult2(ocsanaScore);
        printfinalresult4(elementaryNOdes);

        setElementarypathes();
        printfinalresult(elementarypathes);
        elementaryPathArray();
        //printelementarypatharray();

        exceptionone();
        kEqualOne();
        allpossiblesubset();
        printfinalresultresult(result);

    }

    public void setElementarypathes() {
        hittingsetGreedyGUI.txt.append("\n******************************************************************\n");
        hittingsetGreedyGUI.txt.append("\t" + "setElementarypathes \n");
        hittingsetGreedyGUI.txt.append("******************************************************************\n");
        elementarypathes = new Vector<>();
        for (int i = 0; i < pathes.size(); i++) {
            Vector<Integer> getV = pathes.get(i);

            int sink;

            sink = getV.get(getV.size() - 1);
            for (int j = 0; j < target.length; j++) {

                if (target[j] == sink) {

                    elementarypathes.add(getV);
                    break;
                }
            }
        }
    }

    public Vector<Integer> getElementaryNOdes() {
        return elementaryNOdes;
    }

    public void setElementaryNOdes(Vector<Integer> elementaryNOdes) {
        this.elementaryNOdes = elementaryNOdes;
    }

    public Vector<Float> getOcsanaScore() {
        return ocsanaScore;
    }

    public void setOcsanaScore(Vector<Float> ocsanaScore) {
        this.ocsanaScore = ocsanaScore;
    }

    public int[] getSource() {
        return source;
    }

    public void setSource(int[] source) {
        this.source = source;
    }

    public int[] getTarget() {
        return target;
    }

    public void setTarget(int[] target) {
        this.target = target;
    }

    public int[] getOfftarget() {
        return offtarget;
    }

    public void setOfftarget(int[] offtarget) {
        this.offtarget = offtarget;
    }

    public Vector<Vector<Integer>> getPathes() {
        return pathes;
    }

    public void setPathes(Vector<Vector<Integer>> pathes) {
        this.pathes = pathes;
    }

    public int getRadius() {
        return radius;
    }

    public void setRadius(int radius) {
        this.radius = radius;
    }

    public int getLargeCardinality() {
        return largeCardinality;
    }

    public void setLargeCardinality(int largeCardinality) {
        this.largeCardinality = largeCardinality;
    }

    public int getLargNumberOfCandidate() {
        return largNumberOfCandidate;
    }

    public void setLargNumberOfCandidate(int largNumberOfCandidate) {
        this.largNumberOfCandidate = largNumberOfCandidate;
    }

    public void sort() {//sort in decreasing order not increasing 
        int count = 0;
        inputArr = new Float[ocsanaScore.size()];
        for (int i = 0; i < ocsanaScore.size(); i++) {
            inputArr[count++] = ocsanaScore.get(i);
        }
        this.array = inputArr;
        length = inputArr.length;
        quickSort(0, length - 1);
    }

    private void quickSort(int lowerIndex, int higherIndex) {

        int i = lowerIndex;
        int j = higherIndex;
        // calculate pivot number, I am taking pivot as middle index number
        Float pivot = array[lowerIndex + (higherIndex - lowerIndex) / 2];
        // Divide into two arrays
        while (i <= j) {
            /**
             * In each iteration, we will identify a number from left side which
             * is greater then the pivot value, and also we will identify a
             * number from right side which is less then the pivot value. Once
             * the search is done, then we exchange both numbers.
             */
            while (array[i] < pivot) {
                i++;
            }
            while (array[j] > pivot) {
                j--;
            }
            if (i <= j) {

                exchangeNumbers(i, j);
                //move index to next position on both sides
                i++;
                j--;
            }
        }
        // call quickSort() method recursively
        if (lowerIndex < j) {
            quickSort(lowerIndex, j);
        }
        if (i < higherIndex) {
            quickSort(i, higherIndex);
        }
    }

    private void exchangeNumbers(int i, int j) {

        Float temp = array[i];
        int tempelementarynode;
        tempelementarynode = elementaryNOdes.get(i);

        if (i < j | setscoreset[j] < setscoreset[i]) {

            array[i] = array[j];
            array[j] = temp;

            elementaryNOdes.set(i, elementaryNOdes.get(j));
            elementaryNOdes.set(j, tempelementarynode);

        }
        ocsanaScore.clear();
        for (int k = 0; k < array.length; k++) {
            ocsanaScore.add(array[k]);

        }
    }

    private void elementaryPathArray() {

        hittingsetGreedyGUI.txt.append("\n****************************************\n");
        hittingsetGreedyGUI.txt.append("\t" + "elementaryPathArray" + "\n****************************************\n");
        int N = elementaryNOdes.size();

        int p = elementarypathes.size();

        elementryPathArray = new int[p + 1][N + 1];

        for (int i = 0; i < p + 1; i++) {

            for (int j = 0; j < N + 1; j++) {
                elementryPathArray[i][j] = 0;
            }
        }

        for (int i = 0; i < elementryPathArray.length; i++) {
            for (int j = 0; j < elementryPathArray[i].length; j++) {
                hittingsetGreedyGUI.txt.append(elementryPathArray[i][j] + "\t");
            }
            hittingsetGreedyGUI.txt.append("\n");
        }

        for (int i = 0; i < elementarypathes.size(); i++) {

            for (int j = 1; j < elementarypathes.get(i).size(); j++) {
                hittingsetGreedyGUI.txt.append(i + "  " + j + " " + elementarypathes.get(i).get(j) + "   " + elementaryNOdes.indexOf(elementarypathes.get(i).get(j)));
                elementryPathArray[i + 1][elementaryNOdes.indexOf(elementarypathes.get(i).get(j))] = 1;
            }
            hittingsetGreedyGUI.txt.append("\n");
        }

        for (int i = 0; i < elementryPathArray.length; i++) {
            for (int j = 0; j < elementryPathArray[i].length; j++) {
                hittingsetGreedyGUI.txt.append(elementryPathArray[i][j] + "\t");
            }
            hittingsetGreedyGUI.txt.append("\n");
        }
    }

    private boolean exceptionone() {

        hittingsetGreedyGUI.txt.append("\n****************************************\n");
        hittingsetGreedyGUI.txt.append("\t" + "exception" + "\n****************************************\n");
        boolean excep = false;

        int count = 0;

        for (int i = 1; i < elementryPathArray.length; i++) {

            count = 0;
            for (int j = 0; j < elementryPathArray[i].length; j++) {

                if (elementryPathArray[i][j] == 1) {
                    count++;
                }
            }
            hittingsetGreedyGUI.txt.append(count + "\n");
            if (count == 1) {
                elementryPathArray[i][elementryPathArray[i].length - 1] = -1;
                excep = true;
            }
        }

        return excep;
    }

    private void kEqualOne() {

        hittingsetGreedyGUI.txt.append("\n****************************************\n");
        hittingsetGreedyGUI.txt.append("\t" + "kEqualOne" + "\n****************************************\n");
        int count = 0;

        int N = elementryPathArray[0].length - 1;

        for (int i = 0; i < N; i++) {

            count = 0;
            for (int j = 1; j < elementryPathArray.length; j++) {
                if (elementryPathArray[j][i] == 1) {
                    count++;
                }
            }

            hittingsetGreedyGUI.txt.append(count + "\n");
            if (count == elementryPathArray.length - 1) {
                hittingsetGreedyGUI.txt.append(nodeList.get(i).getName() + "\n");
                elementryPathArray[0][i] = -2;
            }
        }

        hittingsetGreedyGUI.txt.append("finish kEqualOne \n");
    }

    private void allpossiblesubset() {

        hittingsetGreedyGUI.txt.append("\n****************************************\n");
        hittingsetGreedyGUI.txt.append("\t" + "kEqualor greater than 2" + "\n****************************************\n");
        int count = 0;

        int NPrime = 0;

        int c2nprime = 0;

        int[][] H2;

        int[] elementarypathestemp = new int[elementarypathes.size()];

        Vector<Integer> NprimeOrder = new Vector<>();
        Vector<Integer> NprimeVectore = new Vector<>();
        Vector<Vector<Integer>> U;
        Vector<Integer> tempvector;

        for (int i = 0; i < elementryPathArray.length; i++) {
            for (int j = 0; j < elementryPathArray[i].length; j++) {
                hittingsetGreedyGUI.txt.append(elementryPathArray[i][j] + "\t");
            }
            hittingsetGreedyGUI.txt.append("\n");
        }

        int N = elementryPathArray[0].length - 1;
        printfinalresult4(elementaryNOdes);
        for (int i = 0; i < N; i++) {
            hittingsetGreedyGUI.txt.append(i + "  " + elementaryNOdes.get(i) + "   " + nodeList.get(elementaryNOdes.get(i)).getName() + "\n");
            if (elementryPathArray[0][i] != -2) {
                hittingsetGreedyGUI.txt.append(i + "  " + elementryPathArray[0][i] + "\n");
                NprimeOrder.add(elementaryNOdes.get(i));
                NprimeVectore.add(elementaryNOdes.get(i));
                count++;
            }
        }
        for (int i = 0; i < NprimeOrder.size(); i++) {
            hittingsetGreedyGUI.txt.append(NprimeOrder.get(i) + "   " + NprimeVectore.get(i) + "\n");

        }

        hittingsetGreedyGUI.txt.append("\n****************************************\n");

        NPrime = count;

        c2nprime = (int) ((NPrime * (NPrime - 1)) / 2);

        H2 = new int[c2nprime + 1][NPrime + 1];

        for (int i = 0; i < c2nprime + 1; i++) {

            for (int j = 0; j < NPrime + 1; j++) {

                H2[i][j] = 0;
            }
        }

        hittingsetGreedyGUI.txt.append("\n******************H2**********************\n");

        int p = 1;
        int q = 1;
        int t = 0;

        while (true) {

            H2[p][t] = 1;
            if (q < NPrime) {

                H2[p][q] = 1;
                q++;
            } else {
                H2[p][t] = 0;
                t++;
                q = t + 1;

                p--;
            }
            if (p == c2nprime) {
                break;
            }
            p++;
        }

        for (int i = 0; i < c2nprime + 1; i++) {
            for (int j = 0; j < NPrime + 1; j++) {
                hittingsetGreedyGUI.txt.append(H2[i][j] + "\t");
            }
            hittingsetGreedyGUI.txt.append("\n");
        }
        int elementarypathhit = 0;
        int tempvalue1 = -1;
        int tempvalue2 = -1;
        Vector<Vector<Integer>> Useed = new Vector<>();
        Vector<Integer> result1;
        hittingsetGreedyGUI.txt.append("\n******************For page 8 line 2**********************\n");

        for (int i = 1; i < c2nprime + 1; i++) {

            tempvalue1 = -1;
            tempvalue2 = -1;
            elementarypathhit = 0;

            for (int j = 0; j < NPrime; j++) {
                if (H2[i][j] == 1) {

                    if (tempvalue1 == -1) {
                        tempvalue1 = j;
                    } else {
                        tempvalue2 = j;
                    }
                }
            }
            hittingsetGreedyGUI.txt.append(tempvalue1 + "   " + tempvalue2 + "\n");
            hittingsetGreedyGUI.txt.append(nodeList.get(NprimeOrder.get(tempvalue1)).getName() + "   " + nodeList.get(NprimeOrder.get(tempvalue2)).getName() + "\n");
            for (int j = 0; j < elementarypathes.size(); j++) {
                //  hittingsetGreedyGUI.txt.append(NprimeOrder.get(tempvalue1)+"   "+NprimeOrder.get(tempvalue2)+"\n");   
                if (elementarypathes.get(j).contains(NprimeOrder.get(tempvalue1)) | elementarypathes.get(j).contains(NprimeOrder.get(tempvalue2))) {
                    elementarypathhit++;
                }
            }
            result1 = new Vector<>();
            hittingsetGreedyGUI.txt.append(elementarypathhit + "\n");
            if (elementarypathhit == elementarypathes.size()) {
                result1.addElement(NprimeOrder.get(tempvalue1));
                result1.addElement(NprimeOrder.get(tempvalue2));
                result.addElement(result1);
                hittingsetGreedyGUI.txt.append(nodeList.get(NprimeOrder.get(tempvalue1)).getName() + "   " + nodeList.get(NprimeOrder.get(tempvalue2)).getName() + "\n");

            } else {
                tempvector = new Vector<>();
                tempvector.add(NprimeOrder.get(tempvalue1));
                tempvector.add(NprimeOrder.get(tempvalue2));
                Useed.add(tempvector);

            }
        }

        printfinalresultresult(result);
        hittingsetGreedyGUI.txt.append("\n******************k>2*********************\n");
        int z = 0;
        boolean exit = false;
        for (int k = 3; k < largeCardinality && Useed.size() > 0 && Useed.get(Useed.size() - 1).size() < NprimeOrder.size() + 1 && exit == false; k++) {

            if (k == largeCardinality && exceptionone()) {
                break;
            }

            for (int i = 0; i < NprimeOrder.size(); i++) {

                hittingsetGreedyGUI.txt.append(NprimeVectore.get(i) + "\n");
            }

            U = new Vector<>();

            for (int i = 0; i < NprimeVectore.size(); i++) {
                hittingsetGreedyGUI.txt.append(NprimeVectore.get(i) + "  \n");
                for (int j = 0; j < Useed.size(); j++) {
                    int x = 0;
                    for (int l = 0; l < result.size(); l++) {
                        if (comapringtwopath(result.get(l), Useed.get(j))) {

                            x = 1;
                            break;
                        }

                    }

                    if (Useed.get(j).contains(NprimeVectore.get(i)) != true & x == 0) {
                        tempvector = new Vector<>();
                        for (int l = 0; l < Useed.get(j).size(); l++) {
                            tempvector.add(Useed.get(j).get(l));
                            hittingsetGreedyGUI.txt.append(nodeList.get(Useed.get(j).get(l)).getName() + "   ");
                        }

                        tempvector.add(NprimeVectore.get(i));
                        hittingsetGreedyGUI.txt.append(nodeList.get(NprimeVectore.get(i)).getName() + "\n");

                        x = 0;
                        for (int l = 0; l < result.size(); l++) {
                            if (comapringtwopath(result.get(l), tempvector)) {
                                x = 1;
                                break;
                            }
                        }
                        hittingsetGreedyGUI.txt.append(x + "   x\n");
                        if (x == 0) {

                            U.add(tempvector);
                            if (U.size() == largNumberOfCandidate) {
                                exit = true;
                                break;
                            }
                        } else {
                            tempvector.remove(tempvector.size() - 1);
                        }
                    }
                    if (exit) {
                        break;
                    }
                }
                if (exit) {
                    break;
                }
                z = 1;
            }

            Useed.clear();
            Useed = U;
            hittingsetGreedyGUI.txt.append(" \n " + " \n " + Useed.size() + " \n " + " \n ");
            for (int i = 0; i < Useed.size(); i++) {
                // hittingsetGreedyGUI.txt.append(Useed.get(i).size() + "  ");
                for (int j = 0; j < Useed.get(i).size(); j++) {
                    // hittingsetGreedyGUI.txt.append(Useed.get(i).get(j) + "  ");
                    hittingsetGreedyGUI.txt.append(nodeList.get(Useed.get(i).get(j)).getName() + "   ");
                }
                hittingsetGreedyGUI.txt.append(" \n");
            }

            Vector<Vector<Integer>> Utemp = new Vector<>();
            Vector<Integer> tempvector1;
            tempvalue1 = 0;

            if (k == largeCardinality - 1 && exceptionone()) {

                for (int i = 0; i < elementaryNOdes.size(); i++) {

                    if (elementryPathArray[0][i] == -2) {

                        for (int j = 0; j < Useed.size(); j++) {
                            tempvector1 = new Vector<>();
                            tempvector1 = Useed.get(j);
                            tempvector1.add(elementaryNOdes.get(i));
                            int x = 0;
                            for (int l = 0; l < result.size(); l++) {
                                if (comapringtwopath(result.get(l), tempvector1)) {

                                    x = 1;
                                    break;
                                }
                            }
                            if (x == 0) {
                                Utemp.add(tempvector1);
                            }
                        }
                    }

                }
                Useed.clear();
                Useed = Utemp;
            }
            for (int i = 0; i < Useed.size(); i++) {

                for (int j = 0; j < elementarypathestemp.length; j++) {
                    elementarypathestemp[j] = 0;

                }

                for (int l = 0; l < elementarypathes.size(); l++) {
                    for (int j = 0; j < Useed.get(i).size(); j++) {

                        if (elementarypathes.get(l).contains(Useed.get(i).get(j))) {
                            elementarypathestemp[l] = 1;
                            break;
                        }

                    }
                }
                tempvalue1 = 0;
                for (int j = 0; j < elementarypathestemp.length; j++) {
                    if (elementarypathestemp[j] == 1) {
                        tempvalue1++;
                    }
                }

                if (tempvalue1 == elementarypathestemp.length) {

                    int x = 0;
                    for (int l = 0; l < result.size(); l++) {
                        if (comapringtwopath(result.get(l), Useed.get(i))) {

                            x = 1;
                            break;
                        }
                    }
                    if (x == 0) {
                        result.addElement(Useed.get(i));
                    }

                }
            }

        }
    }

    private boolean comapringtwopath(Vector<Integer> oldpath, Vector<Integer> newpath) {
        boolean equal = true;

        int temp = 0;

        for (int i = 0; i < oldpath.size(); i++) {

            if (newpath.contains(oldpath.get(i))) {

                temp++;
            }
        }

        if (temp != oldpath.size()) {
            equal = false;
        }
        return equal;
    }

    public boolean cover(Vector<Integer> current, Vector<Integer> Path1) {

        boolean cover = false;

        for (int i = 0; i < current.size(); i++) {

            if (Path1.contains(current.get(i))) {

                cover = true;
                break;
            }
        }
        return cover;
    }

    public void printfinalresult(Vector<Vector<Integer>> finalresult) {
        hittingsetGreedyGUI.txt.append("\n******************************************************************\n");
        hittingsetGreedyGUI.txt.append("\t" + "pathes \n");
        hittingsetGreedyGUI.txt.append("******************************************************************\n");
        for (int j = 0; j < finalresult.size(); j++) {
            Vector<Integer> get1 = finalresult.get(j);

            for (int k = 1; k < get1.size() - 1; k++) {

                hittingsetGreedyGUI.txt.append(nodeList.get(get1.get(k)).getName());
                int index = nodeList.get(get1.get(k)).getNeighborHashing().indexOf(get1.get(k + 1));
                if (nodeList.get(get1.get(k)).getTypeOfEdge().get(index) == 1) {
                    hittingsetGreedyGUI.txt.append("--->");
                } else {
                    hittingsetGreedyGUI.txt.append("---|");
                }
            }

            hittingsetGreedyGUI.txt.append(nodeList.get(get1.get(get1.size() - 1)).getName() + "\n");

        }

        hittingsetGreedyGUI.txt.append("******************************************************************\n  ");
    }

    public void printfinalresult1(Vector<Integer> finalresult) {

        hittingsetGreedyGUI.txt.append("\n******************************************************************\n");

        Vector<Integer> get1 = finalresult;

        for (int k = 1; k < get1.size() - 1; k++) {

            hittingsetGreedyGUI.txt.append(nodeList.get(get1.get(k)).getName());
            int index = nodeList.get(get1.get(k)).getNeighborHashing().indexOf(get1.get(k + 1));
            if (nodeList.get(get1.get(k)).getTypeOfEdge().get(index) == 1) {
                hittingsetGreedyGUI.txt.append("--->");
            } else {
                hittingsetGreedyGUI.txt.append("---|");
            }
        }

        hittingsetGreedyGUI.txt.append(nodeList.get(get1.get(get1.size() - 1)).getName() + "\n");

        //}
    }

    public void printfinalresult2(Vector<Float> finalresult) {

        hittingsetGreedyGUI.txt.append("\n******************************************************************\n");

        for (int i = 0; i < finalresult.size(); i++) {
            hittingsetGreedyGUI.txt.append(nodeList.get(elementaryNOdes.get(i)).getName() + "  OCSANASCORE IS :   " + finalresult.get(i) + "\n");

        }
    }

    public void printfinalresult3(int[] scoreset) {

        hittingsetGreedyGUI.txt.append("\n******************************************************************\n");

        for (int i = 0; i < elementaryNOdes.size(); i++) {
            hittingsetGreedyGUI.txt.append(nodeList.get(elementaryNOdes.get(i)).getName() + "  score is:   " + scoreset[i] + "\n");

        }
    }

    public void printfinalresult4(Vector<Integer> elementaryNodes) {

        hittingsetGreedyGUI.txt.append("\n******************************************************************\n");

        for (int i = 0; i < elementaryNOdes.size(); i++) {
            hittingsetGreedyGUI.txt.append(nodeList.get(elementaryNOdes.get(i)).getName() + "  elementaryNodes is:   " + elementaryNodes.get(i) + "\n");

        }
    }

    public void printArray(int[] array, String s) {
        hittingsetGreedyGUI.txt.append("\n******************************************************************\n");
        hittingsetGreedyGUI.txt.append("\t" + s + "    is: \n");
        hittingsetGreedyGUI.txt.append("******************************************************************\n");
        for (int i = 0; i < array.length; i++) {
            int b = array[i];

            hittingsetGreedyGUI.txt.append(nodeList.get(b).getName() + "   " + ":  " + b + "\n");
        }

        hittingsetGreedyGUI.txt.append("******************************************************************\n");
    }

    public void printelementarypatharray() {

        hittingsetGreedyGUI.txt.append("\n******************************************************************\n");
        hittingsetGreedyGUI.txt.append("\t elementarypatharray \n ");
        hittingsetGreedyGUI.txt.append("******************************************************************\n");

        for (int i = 0; i < elementryPathArray.length; i++) {

            // printfinalresult4(elementarypathes.get(i));
            // printArray(elementarypathes[i], null);
            for (int j = 0; j < elementryPathArray[i].length; j++) {
                hittingsetGreedyGUI.txt.append(elementryPathArray[i][j] + "\t");
            }
            hittingsetGreedyGUI.txt.append("\n");
        }
        for (int i = 0; i < elementryPathArray[0].length; i++) {
            hittingsetGreedyGUI.txt.append(nodeList.get(elementaryNOdes.get(i)).getName() + "\t");
        }

    }

    public void printfinalresultresult(Vector<Vector<Integer>> resurlt) {
        hittingsetGreedyGUI.txt.append("\n**************************printfinalresultresult*************************************\n");
        hittingsetGreedyGUI.txt.append("path\t\tCI\n");
        for (int i = 0; i < resurlt.size(); i++) {
            Vector<Integer> get = resurlt.get(i);
            for (int j = 0; j < get.size(); j++) {
                Integer get1 = get.get(j);
                hittingsetGreedyGUI.txt.append(nodeList.get(get1).getName() + "   ");
            }
            hittingsetGreedyGUI.txt.append("\t\t" + inputArr[i] + "\n");

        }
        hittingsetGreedyGUI.txt.append("**********************end printfinalresultresult********************************************\n");

    }
}
