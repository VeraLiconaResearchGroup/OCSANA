/**
 * 
 */
package org.cytoscape.myapp.internal;

import java.awt.List;
import java.util.ArrayList;
import java.util.Stack;
import java.util.Vector;

import javax.swing.text.BadLocationException;

/**
 * @author raha
 *
 */
public class path {

	private Graph graph;
	private Node source, sink;
	private int algorithmNumber, maxlength;
	public ArrayList<Node> nodeList;
	public ArrayList<Node> nodeList1;
	private ArrayList<Edge> edgeList;
	public int help = 0;
	private ArrayList<Integer> copyresult;
	private ArrayList<ArrayList<Integer>> allPathes;
	private boolean continueSearch = true;
	private int sizeOdShortestPath = 99999;

	a shortpath;
	a suboptimalpath;
	a allpath;

	public path(Graph g, int algorithmNumber, int maxlength) {
		super();

		this.graph = g;
		this.algorithmNumber = algorithmNumber;
		this.maxlength = maxlength;
		this.nodeList = g.getNode_List();
		this.edgeList = g.getEdges_List();
		this.nodeList1 = g.getNode_List();
		copyresult = new ArrayList<>();
		allPathes = new ArrayList<ArrayList<Integer>>();
		initial();

	}

	private void initial() {
		int[] temparray1;
		int[] temparray2;
		int[] temparray3;
		temparray1 = graph.getSource();
		temparray2 = graph.getTarget();
		temparray3 = graph.getOfftarget();

		if (algorithmNumber == 1) {
			shortpath = new a();
			shortpath.setTitle("shortest path");
			shortpath.setVisible(true);
			for (int i = 0; i < temparray1.length; i++) {
				source = nodeList.get(temparray1[i]);
				for (int j = 0; j < temparray2.length; j++) {
					sink = nodeList.get(temparray2[j]);
					help = 2;
					shortpath.txt.append("**********************" + "\n");
					shortpath.txt.append("\t" + nodeList.get(source.getHashing_map()).getName() + "->"
							+ nodeList.get(sink.getHashing_map()).getName() + "\n");
					shortestPath();
				}

			}

			for (int i = 0; i < temparray1.length; i++) {
				source = nodeList.get(temparray1[i]);
				for (int j = 0; j < temparray3.length; j++) {
					sink = nodeList.get(temparray3[j]);
					help = 2;
					shortpath.txt.append("**********************" + "\n");
					shortpath.txt.append("\t" + nodeList.get(source.getHashing_map()).getName() + "->"
							+ nodeList.get(sink.getHashing_map()).getName() + "\n");
					shortestPath();
				}

			}
			printAllPathes();

		}
		if (algorithmNumber == 2) {
			suboptimalpath = new a();
			suboptimalpath.setTitle("subOPtimal Pathes");
			suboptimalpath.setVisible(true);
			for (int i = 0; i < temparray1.length; i++) {
				source = graph.getNode_List().get(temparray1[i]);
				for (int j = 0; j < temparray2.length; j++) {
					sink = graph.getNode_List().get(temparray2[j]);
					suboptimalpath.txt.append("**********************" + "\n");
					suboptimalpath.txt.append("\t" + nodeList.get(source.getHashing_map()).getName() + "->"
							+ nodeList.get(sink.getHashing_map()).getName() + "\n");
					shortestPath();
					help = 0;

				}

			}

			for (int i = 0; i < temparray1.length; i++) {
				source = graph.getNode_List().get(temparray1[i]);
				for (int j = 0; j < temparray3.length; j++) {
					sink = graph.getNode_List().get(temparray3[j]);
					suboptimalpath.txt.append("**********************" + "\n");
					suboptimalpath.txt.append("\t" + nodeList.get(source.getHashing_map()).getName() + "->"
							+ nodeList.get(sink.getHashing_map()).getName() + "\n");
					shortestPath();
					help = 0;

				}

			}

		}

		if (algorithmNumber == 3) {
			allpath = new a();
			allpath.setTitle("allpaath");
			allpath.setVisible(true);
			boolean[] visited = new boolean[nodeList.size()];

			for (int i = 0; i < temparray1.length; i++) {
				source = graph.getNode_List().get(temparray1[i]);
				for (int j = 0; j < temparray2.length; j++) {
					sink = graph.getNode_List().get(temparray2[j]);
					for (int i1 = 0; i1 < nodeList.size(); i1++) {
						visited[i1] = false;
					}
					allpath.txt.append("**********************" + "\n");
					allpath.txt.append("\t" + nodeList.get(source.getHashing_map()).getName() + "->"
							+ nodeList.get(sink.getHashing_map()).getName() + "\n");
					findAllPath(source.getHashing_map(), sink.getHashing_map(), visited);
				}

			}

			for (int i = 0; i < temparray1.length; i++) {
				source = graph.getNode_List().get(temparray1[i]);
				for (int j = 0; j < temparray3.length; j++) {
					sink = graph.getNode_List().get(temparray3[j]);
					for (int i1 = 0; i1 < nodeList.size(); i1++) {
						visited[i1] = false;
					}
					allpath.txt.append("**********************" + "\n");

					allpath.txt.append("\t" + nodeList.get(source.getHashing_map()).getName() + "->"
							+ nodeList.get(sink.getHashing_map()).getName() + "\n");

					findAllPath(source.getHashing_map(), sink.getHashing_map(), visited);
				}

			}

		}

	}

	public Node getSource() {
		return source;
	}

	public void setSource(Node source) {
		this.source = source;
	}

	public Node getSink() {
		return sink;
	}

	public void setSink(Node sink) {
		this.sink = sink;
	}

	public int getAlgorithmNumber() {
		return algorithmNumber;
	}

	public void setAlgorithmNumber(int algorithmNumber) {
		this.algorithmNumber = algorithmNumber;
	}

	public void shortestPath() {

		int indexsource, indexsink;

		sizeOdShortestPath = 9999;

		int[] visited = new int[nodeList1.size()];

		for (int i = 0; i < visited.length; i++) {

			visited[i] = 0;
		}

		ArrayList<Integer> current = new ArrayList<>();

		indexsource = source.getHashing_map();
		indexsink = sink.getHashing_map();

		visited[indexsource] = 1;
		current.add(indexsource);

		int t = 0;

		int index = 0;


		if (indexsource == indexsink) {

			allPathes.add(current);

		} else {

			shortpath.txt.append("mmmmmmmmmmmmm"+current.size() + "  " + index + "   "
					+ nodeList.get(current.get(current.size() - 1)).getName() + "\n");
			current.add(nodeList.get(indexsource).getNeighborHashing().get(0));

			visited[nodeList.get(indexsource).getNeighborHashing().get(0)] = 1;

			while (current.size() > 0) {

				shortpath.txt.append("mmmmmmmmmmmmm"+current.size() + "  " + index + "   "
					+ nodeList.get(current.get(current.size() - 1)).getName() + "\n");

				while (current.size() < sizeOdShortestPath+1 ) {

					shortpath.txt.append(current.size() + "  " + index + "   "
							+ nodeList.get(current.get(current.size() - 1)).getName() + "\n");

					if (current.get(current.size() - 1) == indexsink) {

						shortpath.txt.append("***************\n");

						if (current.size() < sizeOdShortestPath ) {

							sizeOdShortestPath = current.size();

							allPathes.clear();

							allPathes.add(current);

							printAllPathes();

							t = 1;

						} else {
							shortpath.txt.append("111111111111111*\n");
							
							t = 1;

							allPathes.add(current);
							printAllPathes();
						}

					}

					if (t == 0 & nodeList.get(current.get(current.size()-1)).getNeighborHashing().size()> 0 ) {
						
						int j = 0;
						int k = nodeList.get(current.get(current.size()-1)).getNeighborHashing().size()-1;
						
						for (int i = 0; i < nodeList.get(current.get(current.size()-1)).getNeighborHashing().size() ; i++) {
							
							if(visited[nodeList.get(current.get(current.size()-1)).getNeighborHashing().get(i)] == 0){
								k = i;
								break;
								
							}
						}
						if(visited[nodeList.get(current.get(current.size()-1)).getNeighborHashing().get(k)] == 0){
							shortpath.txt.append("2222222222222222\n");

							
							current.add(nodeList.get(current.get(current.size()-1)).getNeighborHashing().get(k));

							visited[current.get(current.size() - 1)] = 0;
							
							shortpath.txt.append("33333333333333 "+current.size() + "  " + index + "   "
									+ nodeList.get(current.get(current.size() - 1)).getName() + "\n");

							
						}
						else 
						 {
							break;
						}
						
						//current.remove(current.size() - 1);
						
					} else {


						if ( nodeList.get(current.get(current.size()-1)).getNeighborHashing().size()> 0 ) 	{

						visited[current.get(current.size() - 1)] = 0;

						current.remove(current.size() - 1);

						t = 0;
						shortpath.txt.append("44444444444444    "+current.size() + "  " + index + "   "
								+ nodeList.get(current.get(current.size() - 1)).getName() + "\n");

						
						}
						break;
					}

				}

				if (current.size() > 1) {

					index = nodeList.get(current.get(current.size() - 2)).getNeighborHashing()
							.indexOf(current.get(current.size() - 1));

					shortpath.txt.append("5555555555555        "+current.size() + "  " + index + "   "
							+ nodeList.get(current.get(current.size() - 1)).getName() + "\n");
					int tt=0;
					int l = 0;

					while ((nodeList.get(current.get(current.size() - 2)).getNeighborHashing().size() == index + 1) | l == 1) {
						
						shortpath.txt.append("66666666666666666        "+current.size() + "  " + index + "   "
								+ nodeList.get(current.get(current.size() - 1)).getName() + "\n");
						visited[current.get(current.size() - 1)] = 0;

						current.remove(current.size() - 1);
						
						if(current.size() == 1)
						{
							
							tt =1;
							
							break;
							
						}
						index = nodeList.get(current.get(current.size() - 2)).getNeighborHashing()
								.indexOf(current.get(current.size() - 1));
						l =1;
						for (int i = 0; i < nodeList.get(current.get(current.size() - 1)).getNeighborHashing().size(); i++) {
							if (visited[i] == 0) {
								l = 0;
								
							}
						}
					

					}
					
					if (tt != 1) {
						shortpath.txt.append("33333333333333 " + "\n");


						visited[current.size() - 1] = 0;

						current.remove(current.size() - 1);
						
						shortpath.txt.append("66667777       "+current.size() + "  " + index + "   "
								+ nodeList.get(current.get(current.size() - 1)).getName() + "\n");
						l =1;
						for (int i = index +1; i < nodeList.get(current.get(current.size() - 1)).getNeighborHashing().size(); i++) {
							if (visited[i] == 0) {
								l = i;
								break;
							}}

					//	current.add(nodeList.get(current.get(current.size() - 1)).getNeighborHashing().get(index + 1));
						current.add(nodeList.get(current.get(current.size() - 1)).getNeighborHashing().get(l));

						visited[current.get(current.size() - 1)] =1;
						shortpath.txt.append("7777777777777       "+current.size() + "  " + l + "   "
								+ nodeList.get(current.get(current.size() - 1)).getName() + "\n");
					}
					else{
						
						shortpath.txt.append("8888888888888      "+current.size() + "  " + index + "   "
								+ nodeList.get(current.get(current.size() - 1)).getName() + "\n");

						current.remove(0);
						break;
					}
					
					
					
				} else{
					
					shortpath.txt.append("8888888888888      "+current.size() + "  " + index + "   "
							+ nodeList.get(current.get(current.size() - 1)).getName() + "\n");

					current.remove(0);
				}
					

			}

		}

	}
	/*
	 * 
	 * shortpath.txt.append(sizeOdShortestPath + "  "+
	 * currentLength[current.get(0)]+ "   "+
	 * nodeList.get(nodeList.get(current.get(0)).getNeighborHashing().get(i)).
	 * getName()+"\n");
	 * 
	 * if ((currentLength[current.get(0)] <sizeOdShortestPath) &
	 * visited[nodeList.get(current.get(0)).getNeighborHashing().get(i)] == 0 &
	 * (copyresult.indexOf(current.get(0)) + 1 != copyresult
	 * .indexOf(nodeList.get(current.get(0)).getNeighborHashing().get(i)))) {
	 * 
	 * visited[nodeList.get(current.get(0)).getNeighborHashing().get(i)] = 1;
	 * currentLength[nodeList.get(current.get(0)).getNeighborHashing().get(i)] =
	 * currentLength[current.get(0)] +1;
	 * previousIndex[nodeList.get(current.get(0)).getNeighborHashing().get(i)] =
	 * current.get(0);
	 * current.add(nodeList.get(current.get(0)).getNeighborHashing().get(i));
	 * 
	 * if (nodeList.get(current.get(0)).getNeighborHashing().get(i) ==
	 * indexsink) {
	 * 
	 * 
	 * 
	 * visited[indexsink] = 0; temp = previousIndex[indexsink];
	 * result.add(indexsink);
	 * 
	 * while (temp != -1) { visited[temp] = 0; result.add(temp); temp =
	 * previousIndex[temp]; } sizeOdShortestPath = result.size()-1;
	 * shortpath.txt.append(sizeOdShortestPath + "\n");
	 * 
	 * allPathes.add(result); current.remove(current.size()-1);
	 * printAllPathes(); result.clear();
	 * 
	 * } }
	 * 
	 * } current.remove(0); }
	 * 
	 * /*if (previousIndex[indexsink] != -1 || indexsink == indexsource) {
	 * 
	 * temp = previousIndex[indexsink]; result.push(indexsink); while (temp !=
	 * -1) { result.push(temp); temp = previousIndex[temp]; }
	 * allPathes.add(result); }
	 * 
	 * for (int i = 0; i < reversresult.size(); i++)
	 * result.add(reversresult.get(reversresult.size() - i - 1));
	 * 
	 * if (help == 2) printStack(result, 1); else printStack(result, 2);
	 * 
	 * if (copyresult.size() > 0) copyresult.clear(); if (result.size() > 0) for
	 * (int i = 0; i < result.size(); i++) copyresult.add((Integer)
	 * result.get(i));
	 * 
	 * if (help == 0) {
	 * 
	 * help = 1; shortestPath();
	 * 
	 * }
	 */

	Stack<Integer> stack = new Stack<Integer>();

	public void findAllPath(int s, int d, boolean[] visited) {
		// allpath.txt.append(s + " " +nodeList.get(s).getName() );
		stack.add(s);

		if (s == d) {
			printStack(stack, 3);
		}

		if (visited[s] != true)
			visited[s] = true;

		ArrayList<Integer> adjNodes = new ArrayList<>();
		adjNodes = nodeList.get(s).getNeighborHashing(); // getAdjacentNodes(s);

		// if (adjNodes.size() > 0 & stack.size()<maxlength) {
		if (adjNodes.size() > 0) {
			for (int i = 0; i < adjNodes.size(); i++) {
				if (visited[adjNodes.get(i)] != true) {
					// allpath.txt.append( "
					// "+nodeList.get(adjNodes.get(i)).getCanonicalName());
					findAllPath(adjNodes.get(i), d, visited);
				}
			}
		}

		visited[s] = false;
		stack.remove(stack.size() - 1);
	}

	private void printStack(Stack<Integer> stack, int type) {

		if (type == 3) {

			allpath.txt.append("\n");
			for (int i = 0; i < stack.size(); i++)
				allpath.txt.append(nodeList.get(stack.get(i)).getName() + "->");

			allpath.txt.append("\n");

		}

		if (type == 1) {

			for (int i = 0; i < stack.size(); i++)
				shortpath.txt.append(nodeList.get(stack.get(i)).getName() + "->");
			shortpath.txt.append("\n");
		}
		if (type == 2) {

			for (int i = 0; i < stack.size(); i++)
				suboptimalpath.txt.append(nodeList.get(stack.get(i)).getName() + "->");
			suboptimalpath.txt.append("\n");

		}
	}

	private void printAllPathes() {

		// shortpath.txt.append(allPathes.size()+ "\n");
	//	for (int i = 0; i < allPathes.size(); i++) {
			for (int j = 0; j < allPathes.get(0).size(); j++)
				shortpath.txt.append(nodeList.get(allPathes.get(0).get( j)).getName() + "->");
			shortpath.txt.append("\n");

		//}

	}
}
